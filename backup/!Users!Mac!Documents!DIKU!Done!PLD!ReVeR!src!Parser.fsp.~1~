
%{

let p0 = (0,0)

open Microsoft.FSharp.Text.Parsing
open AbSyn

(* parse-error function *)
let mutable ErrorContextDescriptor : string = ""

let parse_error_rich =
  Some (fun (ctxt: ParseErrorContext<_>) ->
    ErrorContextDescriptor <-
      match ctxt.CurrentToken with
      | None -> "At beginning of input\n"
      | Some token -> sprintf "at token %A\n" token
  )

%}

%token <int*(int*int)> INT
%token <string*(int*int)> ID
%token <(int*int)> IF THEN ELSE FI
%token <(int*int)> SUB ADD MULT DIV MOD
%token <(int*int)> GE GT LE LT EQ SWAP OR NOT AND
%token <(int*int)> UNCALL CALL PROCEDURE END
%token <(int*int)> LPAR RPAR SEMI
%token <(int*int)> DEC INC
%token <(int*int)> REPEAT UNTIL
%token <(int*int)> PR RD
%token <(int*int)> DELOC LOC COLON
%token <(int*int)> EOF

%nonassoc ifprec letprec
%left DEQ LTH
%left PLUS MINUS
%left MULT DIVIDE
%left MOD

%start Prog
%type <AbSyn.PROG> Prog
%type <AbSyn.PROC> Proc
%type <AbSyn.STAT> Stat
%type <AbSyn.EXP> Exp

%%
Prog : Stat ProcDecs EOF { ($1, $2) }
;

ProcDecs : PROCEDURE Proc ProcDecs { $2 :: $3 }
         | PROCEDURE Proc          { $2 :: [] }
;

Proc : ID StatList END { Procedure (fst $1, $2, snd $1) }
;

StatList : Stat StatList        { $1 :: $2 }
         | Stat                 { $1 :: [] }
;

Stat : ID DEC Exp     { Dec (fst $1, $3, $2) }
     | ID INC Exp     { Inc (fst $1, $3, $2) }
     | IF Exp THEN StatList ELSE StatList FI Exp
                      { If ($2, $4, $6, $8, $1) }
     | REPEAT StatList UNTIL Exp
                      { Loop ($2, $4, $1) }
     | CALL ID        { Call (fst $2, $1) }
     | UNCALL ID      { Uncall (fst $2, $1) }
     | ID SWAP ID     { Swap (fst $1, fst $3, $2) }
     | PR LPAR ID RPAR
                      { Print ($3) }
     | RD LPAR ID RPAR
                      { Read ($3) }
     | LOC ID COLON Exp StatList DELOC ID COLON Exp
       	      	      { LocBlock (fst $2, $4, $5, fst $7, $9, $1) }
;

Exp : INT              { Constant (fst $1, snd $1) }
    | ID               { Variable ($1) }
    | LPAR Exp RPAR    { $2 }
    | Exp ADD Exp      { Add       ($1, $3, $2) }
    | Exp SUB Exp      { Subtract  ($1, $3, $2) }
    | Exp MULT Exp     { Multiply  ($1, $3, $2) }
    | Exp DIV Exp      { Divide    ($1, $3, $2) }
    | Exp LT Exp       { Less      ($1, $3, $2) }
    | Exp LE Exp       { Lesseq    ($1, $3, $2) }
    | Exp GT Exp       { Greater   ($1, $3, $2) }
    | Exp GE Exp       { Greatereq ($1, $3, $2) }
    | Exp MOD Exp      { Modulo    ($1, $3, $2) }
    | Exp AND Exp      { And       ($1, $3, $2) }
    | Exp OR Exp       { Or        ($1, $3, $2) }
    | NOT Exp          { Not       ($2, $1) }
    | Exp EQ Exp       { Equal     ($1, $3, $2) }
;
%%
